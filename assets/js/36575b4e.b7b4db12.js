"use strict";(self.webpackChunkjstnk=self.webpackChunkjstnk||[]).push([[9852],{3905:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return u}});var n=a(7294);function s(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){s(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,s=function(e,t){if(null==e)return{};var a,n,s={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(s[a]=e[a]);return s}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(s[a]=e[a])}return s}var l=n.createContext({}),h=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},p=function(e){var t=h(e.components);return n.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,s=e.mdxType,i=e.originalType,l=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),c=h(a),u=s,d=c["".concat(l,".").concat(u)]||c[u]||m[u]||i;return a?n.createElement(d,o(o({ref:t},p),{},{components:a})):n.createElement(d,o({ref:t},p))}));function u(e,t){var a=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var i=a.length,o=new Array(i);o[0]=c;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:s,o[1]=r;for(var h=2;h<i;h++)o[h]=a[h];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},193:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return r},contentTitle:function(){return l},metadata:function(){return h},assets:function(){return p},toc:function(){return m},default:function(){return u}});var n=a(7462),s=a(3366),i=(a(7294),a(3905)),o=["components"],r={slug:"TypeRef Hasher-The-imphash-solution-for-samples-in-NET",title:"TypeRef Hasher- The imphash solution for samples in .NET",authors:"joseliyo",tags:["threat intelligence","malware","reversing","cybersecurity","imphash","typerefhasher"]},l=void 0,h={permalink:"/jstnk9/blog/TypeRef Hasher-The-imphash-solution-for-samples-in-NET",source:"@site/blog/2021-02-10-TypeRef Hasher-The-imphash-solution-for-samples-in-NET/2021-02-10-TypeRef Hasher-The-imphash-solution-for-samples-in-NET.md",title:"TypeRef Hasher- The imphash solution for samples in .NET",description:"TL;DR",date:"2021-02-10T00:00:00.000Z",formattedDate:"February 10, 2021",tags:[{label:"threat intelligence",permalink:"/jstnk9/blog/tags/threat-intelligence"},{label:"malware",permalink:"/jstnk9/blog/tags/malware"},{label:"reversing",permalink:"/jstnk9/blog/tags/reversing"},{label:"cybersecurity",permalink:"/jstnk9/blog/tags/cybersecurity"},{label:"imphash",permalink:"/jstnk9/blog/tags/imphash"},{label:"typerefhasher",permalink:"/jstnk9/blog/tags/typerefhasher"}],readingTime:6.695,truncated:!0,authors:[{name:"Jose Luis S\xe1nchez Mart\xednez",title:"Security Researcher",url:"https://twitter.com/Joseliyo_Jstnk",imageURL:"https://jstnk9.github.io/jstnk9/img/profiles/1574890680450.jpeg",key:"joseliyo"}],prevItem:{title:"Indicator life cycle applied to threat hunting",permalink:"/jstnk9/blog/Indicator-life-cycle-applied-to-threat-hunting"},nextItem:{title:"Threat Hunting, but... Where and what? - Collection Management Framework",permalink:"/jstnk9/blog/Threat-hunting-but-where-and-what-collection-management-framework"}},p={authorsImageUrls:[void 0]},m=[{value:"TL;DR",id:"tldr",children:[],level:2},{value:"Problem",id:"problem",children:[],level:2},{value:"Solution",id:"solution",children:[],level:2},{value:"Neossins development",id:"neossins-development",children:[],level:2},{value:"Conclusion",id:"conclusion",children:[],level:2}],c={toc:m};function u(e){var t=e.components,a=(0,s.Z)(e,o);return(0,i.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"tldr"},"TL;DR"),(0,i.kt)("p",null,"Lately I am analyzing many malware samples from different families written in C#, C++ and other languages based on the .NET framework (.NET assembly)."),(0,i.kt)("p",null,"This has led me to find a problem when correlating different samples using hashing techniques, and that is that the imphash in a high percentage was always the same, even with different malware families, however, using other fuzzy hashing techniques I couldn\u2019t find any similarity."),(0,i.kt)("p",null,"The problem is due to the fact that during the compilation of the .NET programming languages, the source code is converted into Microsoft Intermediate Language (MSIL), which causes the same imphash to always exist, corresponding in some cases to the import of the ",(0,i.kt)("strong",{parentName:"p"},"mscoree.dll")," DLL and the ",(0,i.kt)("strong",{parentName:"p"},"_","CorExeMain")," function."),(0,i.kt)("p",null,"I have solved this problem by using another hashing tool called TypeRef Hasher developed by the folks at ",(0,i.kt)("a",{target:"_blank",href:"https://www.gdatasoftware.com/"}," G Data CyberDefense"),". This tool provides a solution to imphash only for .NET malware samples."),(0,i.kt)("p",null,"Taking advantage of the CLI they have available on GitHub, I have developed a small solution that implements and complements it."),(0,i.kt)("h2",{id:"problem"},"Problem"),(0,i.kt)("p",null,"During the last months, analyzing malware samples that were compiled by some programming language in .NET, I always ran into the same imphash, which in many cases made me believe that I was crazy."),(0,i.kt)("p",null,"I was seeing correlations where there weren\u2019t simply because imphash was always the same. For this reason, I started to investigate to see if imphash could really have some kind of bug and I could develop something to fix it, since imphash is one of the indicators I use (from a long list) to correlate malware and to help me later in the attribution processes."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://jstnk9.github.io/jstnk9/img/blog-typerefhasher/typeref_1.png",alt:"Image_1"})),(0,i.kt)("p",null,"The top part of the above image is an AsyncRAT sample which, as you can see, has the same imphash as the AgentTesla sample at the bottom (f34d5f2d4577ed6d9ceec516c1f5a744)."),(0,i.kt)("p",null,"Remembering how imphash works, the hash it produces is based on the DLLs, functions and the order of them in a PE. This fact was what definitely helped me to think that I was not crazy."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://jstnk9.github.io/jstnk9/img/blog-typerefhasher/typeref_2.png",alt:"Image_2"})),(0,i.kt)("p",null,"Both malware samples contain the same imported DLL (mscoree.dll) and the same function (","_","CorExeMain), which must have a reason for this behavior."),(0,i.kt)("p",null,"Looking for information about the ","_","CorExeMain function imported from the DLL in the Microsoft Documentation Center they indicate that it has the following functionality:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Initialize the CLR (Common Language Runtime)"),(0,i.kt)("li",{parentName:"ol"},"Finds the entry point in the CLR header of the executable"),(0,i.kt)("li",{parentName:"ol"},"Normal PE execution begins")),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://jstnk9.github.io/jstnk9/img/blog-typerefhasher/typeref_3.png",alt:"Image_3"})),(0,i.kt)("p",null,"To summarize, a PE that has been compiled with .NET will have its Entry Point to the ","_","CorExeMain() function of the mscoree.dll DLL, which will ensure that the CLR is loaded to execute the rest of the code."),(0,i.kt)("p",null,"Later, at runtime, on demand, the PE will load the rest of the DLLs it needs, that is why in the first instance, the DLLs are not listed in the IAT."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://jstnk9.github.io/jstnk9/img/blog-typerefhasher/typeref_4.png",alt:"Image_4"})),(0,i.kt)("h2",{id:"solution"},"Solution"),(0,i.kt)("p",null,"The folks at G Data CyberDefense ran into the same problem as I did recently and came up with a very interesting development to solve this problem."),(0,i.kt)("p",null,"They have created a hash called TypeRefHash that is based on the TypeRef Table of PEs in .NET."),(0,i.kt)("p",null,"This table stores references to the imported namespaces, having a behavior very similar to that of the DLLs and their functions. For example, if in a PE the DLL Kernel32.dll is imported to make use of the WriteFile function, in a .NET PE the FileStream class of the System.IO namespace can be used."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://jstnk9.github.io/jstnk9/img/blog-typerefhasher/typeref_5.png",alt:"Image_5"})),(0,i.kt)("p",null,"In the previous image you can see part of the TypeRef table of the same AsyncRAT sample above, illustrating as an example how it performs the import of the System.IO namespace and the FileStream class."),(0,i.kt)("p",null,"All this table is finally used to build a hash (TypeRefHash) with the names and namespaces imported by the PE, something very similar to what imphash does with the DLLs."),(0,i.kt)("p",null,"The calculation of the SHA256 hash that they do is based on the following three steps that they indicate in their post."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"They sort the entries by TypeNameSpace and then by TypeName. This is very important, because this way if a new variant of a malware family changes the order of imports, it will not affect the final result of the hash calculation. Empty TypeNameSpaces will be the first to be sorted."),(0,i.kt)("li",{parentName:"ol"},"Concatenate the TypeNamespace and TypeName with a dash. If the TypeNameSpace is empty, the concatenated string begins with the dash."),(0,i.kt)("li",{parentName:"ol"},"All comma-separated strings are joined together and the SHA256 of the resulting UTF8 byte string is then calculated.")),(0,i.kt)("p",null,"An example could be the following, which I wanted to illustrate in an image as a summary."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://jstnk9.github.io/jstnk9/img/blog-typerefhasher/typeref_6.png",alt:"Image_6"})),(0,i.kt)("h2",{id:"neossins-development"},"Neossins development"),(0,i.kt)("p",null,"Based on the G Data CyberDefense tool, I have developed a small application called Neossins in its 0.1 Alpha version, which I will be improving and implementing new features over time."),(0,i.kt)("p",null,"The objective pursued by Neossins is first of all to have a structured and comprehensive dataset of TypeRef Hashes on the main .NET malware families, having so far contemplated three:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"AsyncRAT"),(0,i.kt)("li",{parentName:"ol"},"Blackshades"),(0,i.kt)("li",{parentName:"ol"},"AgentTesla")),(0,i.kt)("p",null,"Once the information is structured and stored in a database, the next step is to compare malware samples received from different sources with the dataset to identify if there is a match with any TypeRef Hash, and if so, to correlate other samples that have the same hash and that were previously stored in the database."),(0,i.kt)("p",null,"Ultimately, it is optimal that new matching samples are stored in the dataset, since the idea is to grow the dataset to be able to know as many TypeRef Hashes as possible for a malware family."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://jstnk9.github.io/jstnk9/img/blog-typerefhasher/typeref_7.jpeg",alt:"Image_7"})),(0,i.kt)("p",null,"The tool has been developed in python3 and has some dependencies such as Cytoscape for the generation of the graph that is displayed in a web application that is raised by Dash."),(0,i.kt)("p",null,"In a series of tests I have been performing using some downloaded malware samples related to AsyncRAT and AgentTesla, the result was the following."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://jstnk9.github.io/jstnk9/img/blog-typerefhasher/typeref_8.png",alt:"Image_8"})),(0,i.kt)("p",null,"The red rectangular nodes are all the samples that I deposited in the directory (the starting point) that must be set in the application\u2019s configuration file."),(0,i.kt)("p",null,"Starting from the left side (blue zone), you can see that there are five nodes that all share the same TypeRef Hash, which could mean that they are variants belonging to the same family."),(0,i.kt)("p",null,"In the central part (red zone), there are three rectangular nodes of red color that are the samples selected to make a comparison with the AsyncRAT family, one of them is the one that has been seen in this post at the beginning of the whole. Two of the three samples, it can be seen that they have a large number of matches previously stored in the dataset, whose nodes are represented by pink circles. All these relationships between nodes means that they share the same TypeRef Hash."),(0,i.kt)("p",null,"Finally, on the right side of the screen, seven orphan nodes that have no match with the dataset can be seen, which could be studied to verify if they could be the families mentioned by means of techniques other than TypeRef Hash, and if so, it would be convenient to store the samples in the dataset."),(0,i.kt)("h2",{id:"conclusion"},"Conclusion"),(0,i.kt)("p",null,"The TypeRef Hash solution is one more feature that can be used to identify malware variants on known families."),(0,i.kt)("p",null,"As I say and reiterate, it is not a definitive and unique solution to be used for the mentioned task, since it can be perfectly used in parallel with other techniques such as ssdeep, VT vhash, imphash for non-.NET files, etc\u2026"),(0,i.kt)("p",null,"The use of imphash for samples compiled using .NET and incorporating only the mscoree.dll DLL and its corresponding ","_","CorExeMain function, has no value since in most cases it will give a false positive in possible relationships of malware samples."),(0,i.kt)("p",null,"Little by little I will update Neossins until I have a stable version and incorporate new features that I want to implement in the future."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Twitter"),": ",(0,i.kt)("a",{parentName:"p",href:"https://twitter.com/Joseliyo_Jstnk"},"https://twitter.com/Joseliyo_Jstnk")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Github"),": ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/jstnk9/neossins"},"https://github.com/jstnk9/neossins")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"LinkedIn"),": ",(0,i.kt)("a",{parentName:"p",href:"https://linkedin.com/in/joseluissm/"},"https://linkedin.com/in/joseluissm/")))}u.isMDXComponent=!0}}]);